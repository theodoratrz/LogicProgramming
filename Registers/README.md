##Summary

Έστω ότι έχουμε στη διάθεσή σας έναν επεξεργαστή που διαθέτει N καταχωρητές R1, R2, ..., RN οι οποίοι έχουν δακτυλιοειδή διευθέτηση. Αυτό σημαίνει ότι μπορεί κάποιος 
να μεταφέρει τα περιεχόμενα του καταχωρητή Ri στον καταχωρητή Ri+1, για 1 <= i < N, και του RN στον R1 με τις εντολές move(i), για 1 <= i < N, και move(N),
αντίστοιχα. Επίσης, μπορεί να αντιμεταθέσει τα περιεχόμενα των καταχωρητών Ri και Rj με την εντολή swap(i,j), όπου i < j. Έστω, τώρα, ότι σας δίνονται τα αρχικά
περιεχόμενα των N καταχωρητών, καθώς και τα επιθυμητά τελικά περιεχόμενα. Το ζητούμενο είναι να βρεθεί η μικρότερη αλληλουχία από τις εντολές move και swap που πρέπει 
να εκτελεσθούν για να επιτευχθεί ο ζητούμενος μετασχηματισμός.

Ορίζουμε το κατηγόρημα codegen/3, έτσι ώστε όταν αυτό καλείται με πρώτο όρισμα τη λίστα των αρχικών περιεχομένων των καταχωρητών και με δεύτερο όρισμα τη λίστα των 
τελικών περιεχομένων, να επιστρέφει στο τρίτο όρισμα τη λίστα των απαραίτητων (ελάχιστων) εντολών που απαιτούνται για το μετασχηματισμό.

Είναι δυνατόν στην αναπαράσταση των περιεχομένων των καταχωρητών να έχουμε, τόσο στην αρχική όσο και στην τελική κατάσταση, το σύμβολο *, που σημαίνει, για μεν την 
αρχική κατάσταση "δεν ξέρω τι περιέχεται στον καταχωρητή", για δε την τελική κατάσταση "δεν με ενδιαφέρει τι περιέχεται στον καταχωρητή". 

Κάποια παραδείγματα εκτέλεσης είναι τα εξής:

`?- codegen([a,b,c,d],[a,d,a,b],L).
L = [move(2),move(1),swap(3,4),swap(2,3)]`

`?- codegen([a,*,c],[c,a,*],L).
L = [move(1),move(3)]`

`?- codegen([a,b,c],[a,a,*],L).
L = [move(1)]`

`?- codegen([a,b,c,d,e,f],[f,f,b,e,a,e],L).
L = [move(2),swap(4,6),move(5),swap(4,5),swap(1,5),move(1)]`
